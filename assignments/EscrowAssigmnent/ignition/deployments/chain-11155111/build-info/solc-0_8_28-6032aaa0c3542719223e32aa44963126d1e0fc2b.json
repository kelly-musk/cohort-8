{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-6032aaa0c3542719223e32aa44963126d1e0fc2b",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Escrow.sol": "project/contracts/Escrow.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Escrow.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ncontract Escrow {\n    // State variables\n    address public buyer;\n    address public seller;\n    address public escrowAgent;\n\n    uint256 public escrowAmount;\n    uint256 public immutable escrowFee; // Fee percentage (e.g., 100 = 1%)\n    uint256 public immutable disputeTimeout; // Time before auto-release\n    uint256 public depositTimestamp;\n\n    bool public deliveryConfirmed;\n    bool public disputed;\n\n    enum EscrowState {\n        AWAITING_PAYMENT,\n        AWAITING_DELIVERY,\n        COMPLETE,\n        REFUNDED,\n        DISPUTED\n    }\n\n    EscrowState public escrowState;\n\n    // Events for transparency\n    event Deposited(address indexed buyer, uint256 amount, uint256 timestamp);\n    event DeliveryConfirmed(address indexed seller, uint256 timestamp);\n    event FundsReleased(address indexed seller, uint256 amount, uint256 fee);\n    event RefundIssued(address indexed buyer, uint256 amount);\n    event DisputeRaised(address indexed initiator, uint256 timestamp);\n    event DisputeResolved(address indexed winner, uint256 amount);\n\n    // Custom errors (gas efficient)\n    error Unauthorized();\n    error InvalidState();\n    error InvalidAmount();\n    error TransferFailed();\n    error DisputeActive();\n    error TimeoutNotReached();\n\n    constructor(\n        address _buyer,\n        address _seller,\n        uint256 _escrowFee, // in basis points (100 = 1%)\n        uint256 _disputeTimeout // in seconds\n    ) {\n        require(_buyer != address(0) && _seller != address(0), \"Invalid address\");\n        require(_buyer != _seller, \"Buyer and seller must differ\");\n        require(_escrowFee <= 1000, \"Fee too high\"); // Max 10%\n\n        buyer = _buyer;\n        seller = _seller;\n        escrowAgent = msg.sender;\n        escrowFee = _escrowFee;\n        disputeTimeout = _disputeTimeout;\n        escrowState = EscrowState.AWAITING_PAYMENT;\n    }\n\n    // Modifiers\n    modifier onlyEscrowAgent() {\n        if (msg.sender != escrowAgent) revert Unauthorized();\n        _;\n    }\n\n    modifier onlyBuyer() {\n        if (msg.sender != buyer) revert Unauthorized();\n        _;\n    }\n\n    modifier onlySeller() {\n        if (msg.sender != seller) revert Unauthorized();\n        _;\n    }\n\n    modifier inState(EscrowState _state) {\n        if (escrowState != _state) revert InvalidState();\n        _;\n    }\n\n    modifier noDispute() {\n        if (disputed) revert DisputeActive();\n        _;\n    }\n\n    /**\n     * @notice Buyer deposits funds into escrow\n     * @dev Only buyer can deposit, only once\n     */\n    function deposit() external payable onlyBuyer inState(EscrowState.AWAITING_PAYMENT) {\n        if (msg.value == 0) revert InvalidAmount();\n\n        escrowAmount = msg.value;\n        depositTimestamp = block.timestamp;\n        escrowState = EscrowState.AWAITING_DELIVERY;\n\n        emit Deposited(buyer, msg.value, block.timestamp);\n    }\n\n    /**\n     * @notice Seller confirms delivery of goods/services\n     * @dev Sets flag that agent can use to release funds\n     */\n    function confirmDelivery() external onlySeller inState(EscrowState.AWAITING_DELIVERY) noDispute {\n        deliveryConfirmed = true;\n        emit DeliveryConfirmed(seller, block.timestamp);\n    }\n\n    /**\n     * @notice Escrow agent releases funds to seller\n     */\n    function releaseFunds() external onlyEscrowAgent inState(EscrowState.AWAITING_DELIVERY) noDispute {\n        require(deliveryConfirmed, \"Delivery not confirmed\");\n\n        uint256 amount = escrowAmount;\n        uint256 fee = (amount * escrowFee) / 10000;\n        uint256 sellerAmount = amount - fee;\n\n        escrowState = EscrowState.COMPLETE;\n        escrowAmount = 0;\n\n        (bool successSeller,) = payable(seller).call{value: sellerAmount}(\"\");\n        if (!successSeller) revert TransferFailed();\n\n        if (fee > 0) {\n            (bool successAgent,) = payable(escrowAgent).call{value: fee}(\"\");\n            if (!successAgent) revert TransferFailed();\n        }\n\n        emit FundsReleased(seller, sellerAmount, fee);\n    }\n\n    /**\n     * @notice Escrow agent refunds buyer\n     */\n    function refundBuyer() external onlyEscrowAgent inState(EscrowState.AWAITING_DELIVERY) {\n        uint256 amount = escrowAmount;\n\n        escrowState = EscrowState.REFUNDED;\n        escrowAmount = 0;\n\n        (bool success,) = payable(buyer).call{value: amount}(\"\");\n        if (!success) revert TransferFailed();\n\n        emit RefundIssued(buyer, amount);\n    }\n\n    /**\n     * @notice Either party can raise a dispute\n     * @dev Freezes the escrow until agent resolves\n     */\n    function raiseDispute() external inState(EscrowState.AWAITING_DELIVERY) {\n        if (msg.sender != buyer && msg.sender != seller) revert Unauthorized();\n\n        disputed = true;\n        escrowState = EscrowState.DISPUTED;\n\n        emit DisputeRaised(msg.sender, block.timestamp);\n    }\n\n    /**\n     * @notice Escrow agent resolves dispute\n     * @param favorBuyer true to refund buyer, false to pay seller\n     */\n    function resolveDispute(bool favorBuyer) external onlyEscrowAgent inState(EscrowState.DISPUTED) {\n        uint256 amount = escrowAmount;\n        address winner = favorBuyer ? buyer : seller;\n\n        // Update state before external calls\n        escrowState = favorBuyer ? EscrowState.REFUNDED : EscrowState.COMPLETE;\n        escrowAmount = 0;\n        disputed = false;\n\n        uint256 fee = favorBuyer ? 0 : (amount * escrowFee) / 10000;\n        uint256 payoutAmount = amount - fee;\n\n        (bool success,) = payable(winner).call{value: payoutAmount}(\"\");\n        if (!success) revert TransferFailed();\n\n        if (fee > 0) {\n            (bool successFee,) = payable(escrowAgent).call{value: fee}(\"\");\n            if (!successFee) revert TransferFailed();\n        }\n\n        emit DisputeResolved(winner, payoutAmount);\n    }\n\n    /**\n     * @notice Auto-release funds after timeout if no dispute\n     * @dev Prevents indefinite lock of funds\n     */\n    function autoRelease() external inState(EscrowState.AWAITING_DELIVERY) noDispute {\n        if (block.timestamp < depositTimestamp + disputeTimeout) {\n            revert TimeoutNotReached();\n        }\n\n        uint256 amount = escrowAmount;\n        uint256 fee = (amount * escrowFee) / 10000;\n        uint256 sellerAmount = amount - fee;\n\n        escrowState = EscrowState.COMPLETE;\n        escrowAmount = 0;\n\n        (bool successSeller,) = payable(seller).call{value: sellerAmount}(\"\");\n        if (!successSeller) revert TransferFailed();\n\n        if (fee > 0) {\n            (bool successAgent,) = payable(escrowAgent).call{value: fee}(\"\");\n            if (!successAgent) revert TransferFailed();\n        }\n\n        emit FundsReleased(seller, sellerAmount, fee);\n    }\n\n    /**\n     * @notice Get contract balance\n     */\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @notice Check if timeout has been reached\n     */\n    function isTimeoutReached() external view returns (bool) {\n        if (escrowState != EscrowState.AWAITING_DELIVERY) return false;\n        return block.timestamp >= depositTimestamp + disputeTimeout;\n    }\n\n    // Reject direct ETH transfers\n    receive() external payable {\n        revert(\"Use deposit() function\");\n    }\n\n    fallback() external {\n        revert(\"Invalid function call\");\n    }\n}\n"
      }
    }
  }
}